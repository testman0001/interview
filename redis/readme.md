## 数据结构
1.string， key-value结构，key为字符串。可用来缓存结构体信息、实现计数功能
2.list，列表。实际是双向链表，能用来实现队列和栈。ziplist：元素较少时使用的特殊编码的双向链表，内存紧凑，每个节点记录上一个元素的长度；quicklist：ziplist+linkedList，既满足了快速的插入删除性能，又不会出现太大的空间冗余。
3.dict（hash），数组加链表的二维结构，用来存结构性数据
4.set，集合，去重场景
5.zset，有序集合，排序场景。内部通过skiplist实现，即链表中取节点再连接成链表，分成多层，从而实现类似二分查找的功能

## 分布式锁
使用setnx + expire来实现，键值对存在时无法成功，因此判断锁被占用
问题：如果线程1超时后被线程2占用，此时线程1再主动释放，就会导致线程3能拿到锁。解决方式：可限制应用仅能释放value对应申请时设置值的锁。

## 延时队列
使用list实现，消费者通过blpop、brpop在没数据时阻塞

## 位图bitmap
即0-1字符串（或者说byte数组），可以用来存储bool类型数据，如签到信息

## 布隆过滤器
快速判断key是否存在集合之中，减轻服务器压力，避免缓存穿透（指的是大量查询不存在redis中的数据，导致后端数据库压力过大，添加布隆过滤器来判断数据是否存在数据库和redis之中，避免进一步访问，其他的方式还有：缓存空对象、调整缓存过期时间、缓存预热）。
使用一个大型位数组和多个hash函数实现，不存在就一定不存在，存在有概率不存在（hash冲突）

## scan
和正则匹配相比，分步执行以避免阻塞redis主线程，能限制输出数量

## redis io模型
主线程是单线程，事件驱动，基于io多路复用监听多个文件描述符（早期是select、后来poll，再后来变成epoll和iocp，只有事件发生时才通知处理）
网络数据读取从6.0往后变成了多线程，以解决网络瓶颈

## 持久化
RDB 全量做快照，采用多进程cow（写时复制）来做快照，做快照的子进程和主进程共享内存，复制时数据如果修改，父进程会复制一份出来，不影响子进程的数据
AOF 将指令写到文件尾部，增量持久化。注意redis执行指令时，是先写aof文件再执行，aof落盘机制由fsync确定。aof重写指读取内存重新生成aof，以减少不必要的指令。
现在一般是rdb+aof混合持久化

## 管道
指客户端连续传多个指令到redis服务器，能极大提升性能，由写读写读变成写写读读。

## 事务的原子性
redis提供事务机制，但是只满足隔离性，事务中指令如果执行失败，那么还是会继续往下执行，而不会自动回滚。

## 订阅
pub/sub，支持多播, 但是无法持久化

## 集群
1.单机模式
2.主从模式
3.sentinal，哨兵模式，自动调整主从
4.cluster，去中心化